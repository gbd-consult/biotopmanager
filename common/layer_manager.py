# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BiotopManager
                                 A QGIS plugin
 Dieses Plugin verwaltet Biotope
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GBD GmbH
        email                : gebbert@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from typing import List
import xml.etree.ElementTree as ET
from qgis.core import QgsVectorLayer, QgsDataSourceUri, QgsWkbTypes, QgsProject
from biotopmanager.common.singleton import Singleton
from biotopmanager.common.database_connection import DatabaseConnection
from biotopmanager.common.configuration import Configuration
from biotopmanager.common.user_credentials import PostgresUser
from biotopmanager.common.utils.logging import qgis_log
from biotopmanager.common.reference_table_manager import ReferenceTableManager


class LayerManager(metaclass=Singleton):
    """This class manages the biotope layers

    1. The original biotope layer, read from the postGIS table
    2. The edit biotope layer, that must be used for editing, which is an in memory layer
    3. The deleted biotope layer, that shows all deleted features from the postGIS history table


    >>> from qgis.core import QgsApplication
    >>> app = QgsApplication([], False)
    >>> app.initQgis()
    >>> conn = DatabaseConnection()
    >>> conn.setup_default_connection()

    >>> lm = LayerManager()
    >>> lm.load_biotope_layer()
    >>> lm.biotope_layer.isValid()
    True
    >>> lm.biotope_layer.crs().isValid()
    True

    >>> lm.load_biotope_edit_layer()
    >>> lm.edit_layer.isValid()
    True
    >>> lm.edit_layer.crs().isValid()
    True

    """

    def __init__(self):
        self._conf = Configuration()
        self._conn = DatabaseConnection()
        self._user = PostgresUser()
        self._refman = ReferenceTableManager()

        self._biotope_layer = None
        self._biotope_deleted_layer = None
        self._history_layer = None
        self._edit_layer = None
        self._locked_layer = None
        self._reference_layers = [] # Not used at the moment

    @property
    def biotope_layer(self) -> QgsVectorLayer:
        return self._biotope_layer

    @property
    def biotope_deleted_layer(self) -> QgsVectorLayer:
        return self._biotope_deleted_layer

    @property
    def history_layer(self) -> QgsVectorLayer:
        return self._history_layer

    @property
    def edit_layer(self) -> QgsVectorLayer:
        return self._edit_layer

    @property
    def locked_layer(self) -> QgsVectorLayer:
        return self._locked_layer

    @property
    def reference_layers(self) -> List[QgsVectorLayer]:
        return self._reference_layers

    def _correct_ui_path_in_style_file(self, layer_style_path, layer_ui_path):
        """Correct the path of the ui file in the style file

        Args:
            layer_style_path: Path to the style file that must be modified
            layer_ui_path: Path to the ui file that must be set in the style file
        """

        tree = ET.parse(layer_style_path)
        root = tree.getroot()

        for elem in root.iter('editorlayout'):
            if elem.text == 'uifilelayout':
                for element in root.iter('editform'):
                    element.text = layer_ui_path

        tree.write(layer_style_path)

    def _correct_key_value_styles(self, layer_style_path: str) -> None:
        """Correct the ValueRelation layer ids in the XML style file

        Args:
            layer_style_path: The style file that must be modified
        """

        tree = ET.parse(layer_style_path)
        root = tree.getroot()

        for edit_widget in root.iter('editWidget'):
            if edit_widget.get("type") == "ValueRelation":
                for option in edit_widget.iter('Option'):
                    if option.get("name") == "Layer":
                        layer_id = option.get("value")
                        for layer in self.reference_layers:
                            if layer.name() in layer_id:
                                option.set("value", layer.id())

        tree.write(layer_style_path)

    def load_biotope_layer(self) -> None:
        """Use this function to load the biotop layer from the database.
        The biotoplayer will be set to read only.
        """

        uri = QgsDataSourceUri()
        uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
        #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
        uri.setDataSource(self._conf.biotope_schema, self._conf.biotope_table_name,
                          self._conf.biotope_geometry_column, "", self._conf.biotope_primary_key)
        # print(uri.uri())
        layer = QgsVectorLayer(uri.uri(), self._conf.biotop_layer_name, "postgres")

        if not layer.isValid():
            raise Exception(f"Kann Layer {self._conf.biotop_layer_name} nicht laden: Uri: {uri.uri()}")

        # Correct the path to the ui file
        self._correct_ui_path_in_style_file(self._conf.biotop_layer_style_path, self._conf.biotop_layer_ui_path)
        # Correct the value map layer ids
        self._correct_key_value_styles(layer_style_path=self._conf.biotop_layer_style_path)
        layer.setReadOnly(True)
        layer.loadNamedStyle(self._conf.biotop_layer_style_path)
        self._biotope_layer = layer

    def load_biotope_history_layer(self) -> None:
        """Use this function to load the biotop history layer from the database.
        The biotop layer will be set to read only and not displayed.
        """

        uri = QgsDataSourceUri()
        uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
        #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
        uri.setDataSource(self._conf.history_schema, self._conf.historie_table_name,
                          self._conf.biotope_geometry_column, "", self._conf.history_primary_key)
        # print(uri.uri())
        layer = QgsVectorLayer(uri.uri(), self._conf.history_layer_name, "postgres")

        if not layer.isValid():
            raise Exception(f"Kann Historien-Layer {self._conf.history_layer_name} nicht laden: Uri: {uri.uri()}")

        # Correct the path to the ui file
        self._correct_ui_path_in_style_file(self._conf.biotop_deleted_layer_style_path, self._conf.biotop_layer_ui_path)
        # Correct the value map layer ids
        self._correct_key_value_styles(layer_style_path=self._conf.biotop_deleted_layer_style_path)
        layer.loadNamedStyle(self._conf.biotop_deleted_layer_style_path)
        layer.setReadOnly(True)
        self._history_layer = layer

    def load_biotope_deleted_layer(self) -> None:
        """Use this function to load the biotop deleted layer from the database.
        The deleted biotop layer will be set to read only and not displayed.
        """

        uri = QgsDataSourceUri()
        uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
        #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
        uri.setDataSource(self._conf.biotop_deleted_schema, self._conf.biotop_deleted_table_name,
                          self._conf.biotope_geometry_column, "", self._conf.history_primary_key)
        # print(uri.uri())
        layer = QgsVectorLayer(uri.uri(), self._conf.biotop_deleted_layer_name, "postgres")

        if not layer.isValid():
            raise Exception(f"Kann Historien-Layer nicht laden: Uri: {uri.uri()}")

        # Correct the path to the ui file
        self._correct_ui_path_in_style_file(self._conf.biotop_deleted_layer_style_path, self._conf.biotop_layer_ui_path)
        # Correct the value map layer ids
        self._correct_key_value_styles(layer_style_path=self._conf.biotop_deleted_layer_style_path)
        layer.loadNamedStyle(self._conf.biotop_deleted_layer_style_path)
        layer.setReadOnly(True)
        self._biotope_deleted_layer = layer

    def load_locked_biotope_layer(self) -> None:
        """Use this function to load the locked biotop layer from the database.
        The locked biotop layer will be set to read only.
        """

        uri = QgsDataSourceUri()
        uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
        #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
        uri.setDataSource(self._conf.biotope_schema, self._conf.locked_biotope_view_name,
                          self._conf.biotope_geometry_column, "", self._conf.biotope_primary_key)
        # print(uri.uri())
        layer = QgsVectorLayer(uri.uri(), self._conf.locked_biotope_layer_name, "postgres")

        if not layer.isValid():
            raise Exception(f"Kann layer {self._conf.locked_biotope_layer_name} nicht laden: Uri: {uri.uri()}")
        layer.setReadOnly(True)

        # Correct the path to the ui file
        self._correct_ui_path_in_style_file(self._conf.locked_biotope_style_path, self._conf.locked_biotope_ui_path)
        # Correct the value map layer ids
        self._correct_key_value_styles(layer_style_path=self._conf.locked_biotope_style_path)
        layer.loadNamedStyle(self._conf.locked_biotope_style_path)
        self._locked_layer = layer

    def load_biotope_edit_layer(self) -> None:
        """Load the edit layer from the postgis database
        """
        schema, temp_table = self._user.edit_table_name.split(".")

        if False:
            table = self._conf.biotope_table_name
            self.create_biotope_edit_layer_postgis(schema=schema, table=table, temp_table=temp_table)

        uri = QgsDataSourceUri()
        uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
        #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
        uri.setDataSource(schema, temp_table,
                          self._conf.biotope_geometry_column, "", self._conf.biotope_primary_key)
        # print(uri.uri())
        layer = QgsVectorLayer(uri.uri(), self._conf.biotop_edit_layer_name, "postgres")

        if not layer.isValid():
            raise Exception(f"Kann layer {self._conf.biotop_edit_layer_name} nicht laden: Uri: {uri.uri()}")

        # Correct the path to the ui file
        self._correct_ui_path_in_style_file(self._conf.biotop_edit_layer_style_path, self._conf.biotop_layer_ui_path)
        # Correct the value map layer ids
        self._correct_key_value_styles(layer_style_path=self._conf.biotop_edit_layer_style_path)
        layer.loadNamedStyle(self._conf.biotop_edit_layer_style_path)
        layer.setReadOnly(False)
        self._edit_layer = layer

    def create_biotope_edit_layer_postgis(self, schema, table, temp_table) -> None:
        """Create a the postgis edit layer that has a user specific name.
        This function will create an exact copy of the biotope table, but without data.

        Args:
            schema: The schema of the biotope table
            table: The name of the biotope table
            temp_table: The name of the edi table that should be created
        """
        # Check if the table already exists
        statement = f"SELECT '{schema}.{temp_table}'::regclass;"
        try:
            self._conn.execute(statement=statement)
        except:
            statement = f"DROP TABLE IF EXISTS {schema}.{temp_table};\n" \
                        f"CREATE TABLE {schema}.{temp_table} AS TABLE {schema}.{table} WITH NO DATA;\n" \
                        f"ALTER TABLE  {schema}.{temp_table} ADD PRIMARY KEY ({self._conf.biotope_primary_key});\n" \
                        f"ALTER TABLE {schema}.{temp_table} ALTER COLUMN {self._conf.biotope_primary_key} " \
                        f"SET DEFAULT nextval('biotope.biotope_ogc_fid_seq'::regclass) ;"
            qgis_log(message=statement)
            self._conn.execute_transaction(statement=statement)

    def load_reference_layers(self):
        """Load all reference layers, they will not be shown
        """

        self._reference_layers.clear()

        for table_name in self._conf.reference_tables:

            uri = QgsDataSourceUri()
            uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, self._conn.password)
            #uri.setConnection(self._conn.host, str(self._conn.port), self._conn.db, self._conn.user, '')
            uri.setDataSource(self._conf.references_schema, table_name, None, "", "id")
            # print(uri.uri())
            layer = QgsVectorLayer(uri.uri(), table_name, "postgres")

            if not layer.isValid():
                raise Exception(f"Kann layer {table_name} nicht laden: Uri: {uri.uri()}")
            layer.setReadOnly(False)
            self._reference_layers.append(layer)

    def show_biotope_layers(self, iface) -> None:
        """Show the biotope layers in a layer group and load its rendering and attribute styles

        1. The orignial biotope layer
        2. The edit layer
        3. The deleted features layer
        """

        layerTree = iface.layerTreeCanvasBridge().rootGroup()

        qproj = QgsProject.instance()

        # Referencelayer must be loaded first
        self.load_reference_layers()
        self.load_biotope_layer()
        self.load_biotope_history_layer()
        self.load_biotope_edit_layer()
        self.load_locked_biotope_layer()
        self.load_biotope_deleted_layer()

        layer_names = []
        layer_names.append(self.edit_layer.name())
        layer_names.append(self.history_layer.name())
        layer_names.append(self.locked_layer.name())
        layer_names.append(self.biotope_layer.name())
        layer_names.append(self.biotope_deleted_layer.name())
        layer_names.extend(self._conf.reference_tables)

        layer_dict = qproj.mapLayers()
        for key in layer_dict:
            map_layer = layer_dict[key]
            if map_layer.name() in layer_names:
                layerTree.removeLayer(map_layer)
                qproj.removeMapLayer(map_layer)

        layerTree.removeChildrenGroupWithoutLayers()

        qproj.addMapLayer(self.edit_layer, False)
        qproj.addMapLayer(self.history_layer, False)
        qproj.addMapLayer(self.locked_layer, False)
        qproj.addMapLayer(self.biotope_layer, False)
        qproj.addMapLayer(self.biotope_deleted_layer, False)

        newGroup = layerTree.addGroup("Biotopkataster")
        newGroup.addLayer(self.edit_layer)
        newGroup.addLayer(self.locked_layer)
        newGroup.addLayer(self.biotope_layer)
        newGroup.addLayer(self.biotope_deleted_layer)
        # newGroup.addLayer(self.history_layer)

        referenceGroup = layerTree.addGroup("Referenztabellen")
        for layer in self._reference_layers:
            qproj.addMapLayer(layer, False)
            referenceGroup.addLayer(layer)

        referenceGroup.setExpanded(False)

        QgsProject.instance().setCrs(self.biotope_layer.crs())


if __name__ == "__main__":
    import doctest

    doctest.testmod()
