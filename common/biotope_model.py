# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BiotopManager
                                 A QGIS plugin
 Dieses Plugin verwaltet Biotope
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GBD GmbH
        email                : gebbert@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from enum import Enum
from functools import wraps
from typing import List, Tuple
from biotopmanager.common.singleton import Singleton
from biotopmanager.common.database_connection import DatabaseConnection
from biotopmanager.common.configuration import Configuration
from biotopmanager.common.user_credentials import PostgresUser


class BiotopOrigin(Enum):
    PUBLIC = 1
    TEMPORARY = 2
    HISTORY = 3


# Decorator for lazy loading
def check_data(method):
    @wraps(method)
    def _impl(self, *args, **kwargs):
        # Use lazy loading when possible
        if not self._cache:
            self._load_data()
        return method(self, *args, **kwargs)

    return _impl


class BiotopeModel(metaclass=Singleton):
    """This class manages all reference tables and caches them
    in the internal cache.

    It will store the reference table columns and the column names for each table.

    >>> conn = DatabaseConnection()
    >>> conn.setup_default_connection()
    >>> conn.connect()
    >>> bm = BiotopeModel()
    >>> t = bm.get_biotope_column_names()
    >>> len(t) > 0
    True
    >>> t = bm.get_edit_column_names()
    >>> t = bm.get_history_column_names()
    >>> len(t) > 0
    True
    >>> result = bm.get_attributes(ogc_fid=166)
    >>> print(result[17])
    60
    >>> result[0] == 166
    True
    >>> result = bm.get_mapped_attributes(ogc_fid=166)
    >>> print(result[17])
    Streuobstwiese

    >>> result = bm.get_attributes(ogc_fid=166, origin=BiotopOrigin.HISTORY)
    >>> print(result[17])
    60
    >>> result[0] == 8352
    True
    >>> result = bm.get_mapped_attributes(ogc_fid=166, origin=BiotopOrigin.HISTORY)
    >>> print(result[17])
    Streuobstwiese

    """

    def __init__(self):
        self._conf = Configuration()
        self._conn = DatabaseConnection()
        self._user = PostgresUser()
        self._tables = set()
        self._cache = {}

        self._biotope_table = f"{self._conf.biotope_schema}.{self._conf.biotope_table_name}"
        self._history_table = f"{self._conf._history_schema}.{self._conf._historie_table_name}"
        self._edit_table = self._user.edit_table_name

        self._tables.add(self._biotope_table)
        self._tables.add(self._history_table)
        self._tables.add(self._edit_table)

    @property
    def biotope_table(self):
        return self._biotope_table

    @property
    def history_table(self):
        return self._history_table

    @property
    def edit_table(self):
        return self._edit_table

    def _load_data(self):
        """Load all table columns at once
        """

        for schema_table in self._tables:
            self._cache[schema_table] = {}
            schema, table = schema_table.split(".")
            column_names = self._get_column_names(schema=schema, table=table)
            self._cache[schema_table]["column_names"] = column_names

    def _get_column_names(self, schema: str, table: str) -> List[str]:
        """Get all column names of schema.table

        Args:
            schema: The schema name
            table_name: The table name

        Returns:
            list
            The list of column names
        """

        statement = f"SELECT column_name FROM information_schema.columns " \
                    f"WHERE table_schema = '{schema}' AND table_name = '{table}';"
        self._conn.execute(statement=statement)
        self._conn.commit()
        columns = self._conn.fetch_all()
        if columns is None:
            raise Exception(f"Kann Spalten aus tabelle {table} nicht laden.")

        return [entry[0] for entry in columns]

    @check_data
    def get_biotope_column_names(self):
        return self._cache[self._biotope_table]["column_names"]

    @check_data
    def get_history_column_names(self):
        return self._cache[self._history_table]["column_names"]

    @check_data
    def get_edit_column_names(self):
        return self._cache[self._edit_table]["column_names"]

    def get_next_biotop_id(self) -> int:
        """Get a new valid primary key id from the biotop table sequence

        Returns:
            int
            The new unique id

        """
        statement = "SELECT nextval('biotope.biotope_ogc_fid_seq'::regclass)"
        self._conn.execute(statement=statement)
        _id = self._conn.fetch_one()
        return int(_id[0])

    def orig_edit_feature_equal(self, ogc_fid: int) -> bool:
        """Check if the original and the edit feature are equal

        Args:
            ogc_fid: The feature id of the feature

        Returns:
            bool
            True if they are equal, False otherwise

        """

        cols = ",".join(self.get_biotope_column_names())
        pk = self._conf.biotope_primary_key
        statement_orig = f"SELECT  md5(CONCAT({cols})) FROM {self._biotope_table} WHERE {pk} = {ogc_fid}"
        statement_edit = f"SELECT  md5(CONCAT({cols})) FROM {self._edit_table} WHERE {pk} = {ogc_fid}"
        statement = f"SELECT ({statement_orig}) = ({statement_edit});"
        self._conn.execute(statement=statement)
        self._conn.commit()
        check = self._conn.fetch_one()
        return check[0]

    def get_attributes(self, ogc_fid: int, origin: BiotopOrigin = BiotopOrigin.PUBLIC) -> list:
        """Return the attributes of a single feature

        Args:
            ogc_fid: The feature id of the feature
            origin: Set True is the history table should be used

        Returns:
            a list of values

        """
        statement = ""
        if origin is BiotopOrigin.HISTORY:
            cols = ",".join(self.get_history_column_names())
            pk = self._conf.history_primary_key
            statement = f"SELECT  {cols} FROM {self._history_table} WHERE {pk} = {ogc_fid}"
        elif origin is BiotopOrigin.PUBLIC:
            cols = ",".join(self.get_biotope_column_names())
            pk = self._conf.biotope_primary_key
            statement = f"SELECT  {cols} FROM {self._biotope_table} WHERE {pk} = {ogc_fid}"
        elif origin is BiotopOrigin.TEMPORARY:
            cols = ",".join(self.get_edit_column_names())
            pk = self._conf.biotope_primary_key
            statement = f"SELECT  {cols} FROM {self._edit_table} WHERE {pk} = {ogc_fid}"

        try:
            self._conn.execute(statement=statement)
            self._conn.commit()
            result = self._conn.fetch_one()
        except:
            raise
        return result

    def get_mapped_attributes(self, ogc_fid: int, origin: BiotopOrigin = BiotopOrigin.PUBLIC) -> Tuple[List, List]:
        """Return the attributes of a single feature which were mapped with the lookup tables

        Args:
            ogc_fid: The feature id of the feature
            origin: Set True is the history table should be used

        Returns:
            a list of values

        """
        columns = None

        if origin is BiotopOrigin.HISTORY:
            columns = self.get_history_column_names()
        elif origin is BiotopOrigin.PUBLIC:
            columns = self.get_biotope_column_names()
        elif origin is BiotopOrigin.TEMPORARY:
            columns = self.get_edit_column_names()

        if not columns:
            return [], []

        attributes = self.get_attributes(ogc_fid=ogc_fid, origin=origin)

        if not attributes:
            return list(), list()

        mapped_cols = self._conf.mapped_columns

        attribute_list = []
        for column, attribute in zip(columns, attributes):
            if column in mapped_cols.keys():
                entry = mapped_cols[column]
                attribute = self.get_reference_table_attribute(table=entry["table"], key_column=entry["key"],
                                                               value_column=entry["value"], key=attribute)
            attribute_list.append(attribute)

        return attribute_list, columns

    def get_reference_table_attribute(self, table: str, key_column: str, value_column: str, key: str):
        """Get an entry from a reference table

        Args:
            table: The reference table name
            key_column: The primary key or id column name
            value_column: The column name to select the value from
            key: The primary key or id

        """
        if key:
            #qgis_log("The key before: " + str((key)))
            if isinstance(key, list):
                if not key[0] or key[0] == '':
                    return None
            # We need to check the key for multiple entries
            if "{" in key:
                if "{}" in key:
                    return None
                keys = key.replace("{", "").replace("}", "")
                key = keys.split(",")
            #qgis_log("The key class: " + str(type(key)).replace("<", "").replace(">", ""))
            #qgis_log("The key: " + str((key)))

            if isinstance(key, list):
                statement = f"SELECT {value_column} FROM {self._conf.references_schema}.{table} WHERE {key_column} = ANY(%s::INT[]);"
            else:
                statement = f"SELECT {value_column} FROM {self._conf.references_schema}.{table} WHERE {key_column} = %s;"
            statement = self._conn.mogrify(statement=statement, args=[key])
            #qgis_log(statement.decode("utf-8"))
            self._conn.execute(statement=statement)
            self._conn.commit()
            result = self._conn.fetch_all()
            #qgis_log("Result 1 " + str(result))
            if result:
                if len(result) == 1:
                    result = result[0][0]
                else:
                    result_list = []
                    for entry in result:
                        result_list.append(entry[0])
                    result = str(result_list)
            else:
                result = None

            #qgis_log("Result 2 " + str(result))
            return result
        return None


if __name__ == "__main__":
    import doctest

    doctest.testmod()
