# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BiotopManager
                                 A QGIS plugin
 Dieses Plugin verwaltet Biotope
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GBD GmbH
        email                : gebbert@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from datetime import datetime
from typing import List
from biotopmanager.common.singleton import Singleton
from biotopmanager.common.configuration import Configuration
from biotopmanager.common.database_connection import DatabaseConnection


class BiotopLock(object):
    """This class represents a single biotop lock entry
    """

    def __init__(self, biotop_id: int, user_id: str, mod_time: datetime):
        self._biotop_id = biotop_id
        self._user_id = user_id
        self._mod_time = mod_time

    @property
    def user_id(self) -> str:
        return self._user_id

    @property
    def biotop_id(self) -> int:
        return self._biotop_id

    @property
    def mod_time(self) -> datetime:
        return self.mod_time


class BiotopeLocking(metaclass=Singleton):
    """This class takes care of the object locking

    >>> conn = DatabaseConnection()
    >>> conn.setup_default_connection()
    >>> conn.execute_transaction("TRUNCATE biotope.locks;")

    >>> l = BiotopeLocking()
    >>> l.lock(biotop_ids=[100000000, 100000001], user_id="soeren")
    True
    >>> l.is_locked(biotop_id=100000000)
    True
    >>> l.is_locked(biotop_id=100000000, user_id="soeren")
    True
    >>> l.is_locked(biotop_id=100000000, user_id="franz")
    False
    >>> locks = l.get_locks()
    >>> len(locks)
    2
    >>> locks[0].user_id
    'soeren'
    >>> locks[0].biotop_id
    100000000

    >>> locks[1].user_id
    'soeren'
    >>> locks[1].biotop_id
    100000001

    >>> locks = l.get_locks(user_id="soeren")
    >>> len(locks)
    2

    >>> locks = l.get_locks(user_id="franz")
    >>> len(locks)
    0

    >>> l.lock(biotop_ids=[100000000, 100000001], user_id="soeren")
    duplicate key value violates unique constraint "biotope_locks_uk1"
    DETAIL:  Key (biotop_id)=(100000000) already exists.
    <BLANKLINE>
    False
    >>> l.lock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    duplicate key value violates unique constraint "biotope_locks_uk1"
    DETAIL:  Key (biotop_id)=(100000000) already exists.
    <BLANKLINE>
    False
    >>> l.unlock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    True
    >>> l.is_locked(biotop_id=100000000)
    False
    >>> l.lock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    True
    >>> locks = l.get_locks()
    >>> len(locks)
    3

    >>> l.lock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    duplicate key value violates unique constraint "biotope_locks_uk1"
    DETAIL:  Key (biotop_id)=(100000002) already exists.
    <BLANKLINE>
    False
    >>> l.unlock_user(user_id="soeren")
    True
    >>> l.lock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    True
    >>> l.unlock(biotop_ids=[100000002, 100000000, 100000001], user_id="soeren")
    True
    >>> l.lock_id(biotop_id=100000001, user_id="soeren")
    True
    >>> l.lock_id(biotop_id=100000001, user_id="Franz")
    duplicate key value violates unique constraint "biotope_locks_uk1"
    DETAIL:  Key (biotop_id)=(100000001) already exists.
    <BLANKLINE>
    False
    >>> conn.execute_transaction("TRUNCATE biotope.locks;")

    """

    def __init__(self):
        self._conn = DatabaseConnection()
        self._config = Configuration()

    def lock_id(self, biotop_id: int, user_id: str) ->bool:
        """Lock a single biotop id for a specific user

        Args:
            biotop_id: The unique id of a biotop
            user_id: The user id

        Returns:
            bool
            True if locking was successful, False otherwise
        """
        return self.lock(biotop_ids=[biotop_id,], user_id=user_id)

    def lock_sql(self, biotop_ids: List[int], user_id: str) -> str:
        """Get the SQL statement to lock a several biotop ids for a specific user

        Args:
            biotop_ids (list): A list of unique biotop ids
            user_id (str): The user id

        Returns:
            str
            The SQL statement
        """
        schema = self._config.biotope_schema
        table = self._config.lock_table
        statements = []
        for biotop_id in biotop_ids:
            statement = f"INSERT INTO {schema}.{table} (biotop_id, user_id) VALUES (%s, %s);\n"
            statement = self._conn.mogrify(statement, [biotop_id, user_id])
            statements.append(statement.decode("utf-8"))
        return "\n".join(statements)

    def lock(self, biotop_ids: List[int], user_id: str) -> bool:
        """Lock a several biotop ids for a specific user

        Args:
            biotop_ids (list): A list of unique biotop ids
            user_id (str): The user id

        Returns:
            bool
            True if locking was successful, False otherwise
        """
        try:
            statement = self.lock_sql(biotop_ids=biotop_ids, user_id=user_id)
            # print(statement)
            self._conn.execute_transaction(statement)
            return True
        except Exception as e:
            self._conn.rollback()
            print(str(e))
            return False

    def unlock_sql(self, biotop_ids: List[int], user_id: str) -> str:
        """Get the SQL statement to unlock a several biotop ids for a specific user

        Args:
            biotop_id: The unique id of a biotop
            user_id: The user id

        Returns:
            str
            The SQL statement
        """
        schema = self._config.biotope_schema
        table = self._config.lock_table
        statements = []
        for biotop_id in biotop_ids:
            statement = f"DELETE FROM {schema}.{table} WHERE biotop_id = %s AND user_id = %s;"
            statement = self._conn.mogrify(statement, [biotop_id, user_id])
            statements.append(statement.decode("utf-8"))
        return "\n".join(statements)

    def unlock(self, biotop_ids: List[int], user_id: str) -> bool:
        """Unlock a several biotop ids for a specific user

        Args:
            biotop_id: The unique id of a biotop
            user_id: The user id

        Returns:
            bool
            True if unlocking was successful, False otherwise
        """
        try:
            statement = self.unlock_sql(biotop_ids=biotop_ids, user_id=user_id)
            self._conn.execute_transaction(statement)
            return True
        except Exception as e:
            self._conn.rollback()
            print(str(e))
            return False

    def unlock_user_sql(self, user_id: str) -> str:
        """Get the SQL statement to unlock all biotop ids of a specific user

        Args:
            user_id: The user id

        Returns:
            str
            The SQL statement
        """
        schema = self._config.biotope_schema
        table = self._config.lock_table
        statement = f"DELETE FROM {schema}.{table} WHERE user_id = %s;"
        statement = self._conn.mogrify(statement, [user_id,])
        return statement.decode("utf-8")

    def unlock_user(self, user_id: str) -> bool:
        """Unlock all biotop ids of a specific user

        Args:
            user_id: The user id

        Returns:
            bool
            True if unlocking was successful, False otherwise
        """
        try:
            statement = self.unlock_user_sql(user_id=user_id)
            self._conn.execute_transaction(statement)
            return True
        except Exception as e:
            self._conn.rollback()
            print(str(e))
            return False

    def is_locked(self, biotop_id: int, user_id: str = None) ->bool:
        """Check if a specific biotop id is locked

        Args:
            biotop_id: The unique id of a biotop
            user_id: The optional user id

        Returns:
            True if the lock exists, False otherwise

        """
        schema = self._config.biotope_schema
        table = self._config.lock_table
        if user_id is not None:
            statement = f"SELECT biotop_id FROM {schema}.{table} WHERE biotop_id = {biotop_id} AND user_id = '{user_id}';"
        else:
            statement = f"SELECT biotop_id FROM {schema}.{table} WHERE biotop_id = {biotop_id};"
        try:
            self._conn.execute(statement)
            result = self._conn.fetch_one()
            if result:
                return True
        except Exception as e:
            self._conn.rollback()
            print(str(e))
        return False

    def get_locks(self, user_id = None) -> List[BiotopLock]:
        """Return a list of all biotop_id's that are locked

        Args:
            user_id: The optional user id for which all locks should be returned

        Returns:
            list
            A list of BiotopLovk's

        """
        schema = self._config.biotope_schema
        table = self._config.lock_table
        biotop_lock_list = []
        if user_id is not None:
            statement = f"SELECT biotop_id, user_id, mod_time FROM {schema}.{table} WHERE user_id = '{user_id}';"
        else:
            statement = f"SELECT biotop_id, user_id, mod_time FROM {schema}.{table};"
        try:
            self._conn.execute(statement)
            rows = self._conn.fetch_all()
            if rows:
                for row in rows:
                    b = BiotopLock(biotop_id=int(row[0]), user_id=row[1], mod_time=row[2])
                    biotop_lock_list.append(b)

        except Exception as e:
            self._conn.rollback()
            print(str(e))

        return biotop_lock_list


if __name__ == "__main__":
    import doctest

    doctest.testmod()
