# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BiotopManager
                                 A QGIS plugin
 Dieses Plugin verwaltet Biotope
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GBD GmbH
        email                : gebbert@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from typing import List, Optional
import datetime
import psycopg2
from biotopmanager.common.singleton import Singleton
from biotopmanager.common.configuration import Configuration
from biotopmanager.common.utils.logging import qgis_log
from biotopmanager.common.user_credentials import PostgresUser


class DatabaseConnection(metaclass=Singleton):
    """A simple database connection wrapper around the psycopg2 module

    This class uses a timeout to reconnect after a specific number of seconds


    >>> conn = DatabaseConnection()
    >>> conn.setup_default_connection()
    >>> conn.connect()
    >>> conn.execute("SELECT lower('HELLO');")
    >>> conn.fetch_one()
    ('hello',)
    >>> conn.is_connected
    True
    >>> conn.close()
    >>> conn.is_connected
    False

    >>> conn.execute("SELECT lower('HELLO');")
    >>> conn.fetch_one()
    ('hello',)
    >>> conn.is_connected
    True

    >>> config = Configuration()
    >>> conn.set_connection(host=config.default_host, port=config.default_port, db=config.default_db)
    >>> conn.set_user_password(user=config.default_user, password=config.default_password)
    >>> conn.execute("SELECT lower('HELLO');")
    >>> conn.fetch_one()
    ('hello',)
    >>> conn.is_connected
    True

    """

    def __init__(self):
        self._host = None
        self._port = None
        self._db = None
        self._user = None
        self._password = None

        self._cursor = None
        # We have a time limit of the database connection
        self._connection_time_limit = 300
        self._last_execution_time = datetime.datetime.now()

        self._is_connected = False
        self._conn = None

    def setup_default_connection(self):
        config = Configuration()
        user = PostgresUser()
        self._host = config.default_host
        self._port = config.default_port
        self._db = config.default_db
        self._user = config.default_user
        self._password = config.default_password

        user.user_id = self._user
        user.password = self._password

    @property
    def is_connected(self) -> bool:
        return self._is_connected

    @property
    def host(self) ->str:
        return self._host

    @property
    def port(self) -> str:
        return self._port

    @property
    def db(self) -> str:
        return self._db

    @property
    def user(self) -> str:
        return self._user

    @property
    def password(self) -> str:
        return self._password

    def set_connection(self, host, port, db):
        self._host = host
        self._port = port
        self._db = db

    def set_user_password(self, user, password):
        self._user = user
        self._password = password

    @property
    def last_execution_time(self) -> datetime.datetime:
        return self._last_execution_time

    @property
    def connection_time_limit(self) -> int:
        return self._connection_time_limit

    @connection_time_limit.setter
    def connection_time_limit(self, time_limit: int = 300):
        if 0 < time_limit <= 1200:
            self._connection_time_limit = time_limit
        else:
            raise ValueError("Das Zeitlimit für die Datenbankverbindung mut gröer 0 und kleiner 1200s sein.")

    @property
    def dbString(self) -> str:
        return f"dbname={self.db} host={self.host} user={self.user} password={self.password} port={self.port}"

    def rollback(self) -> None:
        if self.is_connected:
            self._conn.rollback()

    def connect(self) -> None:
        self._is_connected = False
        try:
            self._conn = psycopg2.connect(self.dbString, connect_timeout=20)
            self._cursor = self._conn.cursor()
            self._is_connected = True
        except Exception:
            raise

    def close(self) -> None:
        if self.is_connected:
            self._conn.commit()
            self._cursor.close()
        self._is_connected = False

    def commit(self) -> None:
        if self.is_connected:
            self._conn.commit()

    def _check(self):
        diff = datetime.datetime.now() - self._last_execution_time
        if diff.seconds >= self._connection_time_limit:
            self.connect()

        if self.is_connected is False:
            self.connect()

    def execute(self, statement: str, args=None) -> None:
        self._check()
        try:
            if args:
                self._cursor.execute(statement, args)
            else:
                self._cursor.execute(statement)
            self._last_execution_time = datetime.datetime.now()
        except psycopg2.ProgrammingError or psycopg2.InternalError or psycopg2.IntegrityError:
            self.rollback()
            self.close()
            raise
        except psycopg2.DatabaseError or psycopg2.InterfaceError or psycopg2.OperationalError:
            self.connected = False
            raise

    def execute_transaction(self, statement: str) -> None:

        sql_script = "BEGIN TRANSACTION;\n%s\nEND TRANSACTION;"%statement

        self._check()
        try:
            self._cursor.execute(sql_script)
            self._conn.commit()
            self._last_execution_time = datetime.datetime.now()
        except psycopg2.ProgrammingError or psycopg2.InternalError or psycopg2.IntegrityError:
            self.rollback()
            self.close()
            raise
        except psycopg2.DatabaseError or psycopg2.InterfaceError or psycopg2.OperationalError:
            self._is_connected = False
            raise

    def mogrify(self, statement: str, args=None) -> str:
        if len(args) == 0:
            return statement

        self._check()
        try:
            return self._cursor.mogrify(statement, args)
        except:
            raise

    def fetch_one(self) -> Optional[List[str]]:
        if self.is_connected:
            return self._cursor.fetchone()
        return None

    def fetch_all(self) -> Optional[List[str]]:
        if self.is_connected:
            return self._cursor.fetchall()
        return None


if __name__ == "__main__":
    import doctest

    doctest.testmod()
