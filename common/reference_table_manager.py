# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BiotopManager
                                 A QGIS plugin
 Dieses Plugin verwaltet Biotope
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GBD GmbH
        email                : gebbert@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from functools import wraps
import tempfile
import os
import sys
from typing import List, Tuple, Optional
from qgis.core import QgsVectorLayer, QgsDataSourceUri, QgsWkbTypes, QgsProject
from biotopmanager.common.singleton import Singleton
from biotopmanager.common.database_connection import DatabaseConnection
from biotopmanager.common.configuration import Configuration
from biotopmanager.common.user_credentials import PostgresUser
from biotopmanager.common.utils.logging import qgis_log


TEMPLATE = """              <Option type="Map"><Option type="QString" name="%s" value="%s"/></Option>"""

BODY = """\
        <config>
          <Option type="Map">
            <Option type="List" name="map">
<-- placeholder-->
            </Option>
          </Option>
        </config>\
"""


# Decorator for lazy loading
def check_data(method):
    @wraps(method)
    def _impl(self, *args, **kwargs):
        # Use lazy loading when possible
        if not self._cache:
            self._load_data()
        return method(self, *args, **kwargs)

    return _impl


class ReferenceTableManager(metaclass=Singleton):
    """This class manages all reference tables and caches them
    in the internal cache.

    It will store the reference table columns and the column names for each table.

    >>> conn = DatabaseConnection()
    >>> conn.setup_default_connection()
    >>> conn.connect()
    >>> rfm = ReferenceTableManager()
    >>> rfm._get_column_names(schema="referenzen", table="aenderungen")
    ['id', 'aenderung']

    >>> rfm._get_columns(schema="referenzen", table="aenderungen")
    [(1, 'Standardmaßnahme'), (2, 'Überführung ohne Anpassung'), (3, 'Überführung mit Anpassung'), (4, 'Detailplanung '), (5, 'Änderung Schutzgut'), (6, 'Maßnahmekorrektur')]

    >>> s = rfm.style_map(table="aenderungen")
    >>> print(s)
            <config>
              <Option type="Map">
                <Option type="List" name="map">
                  <Option type="Map"><Option type="QString" name="Standardmaßnahme" value="1"/></Option>
                  <Option type="Map"><Option type="QString" name="Überführung ohne Anpassung" value="2"/></Option>
                  <Option type="Map"><Option type="QString" name="Überführung mit Anpassung" value="3"/></Option>
                  <Option type="Map"><Option type="QString" name="Detailplanung " value="4"/></Option>
                  <Option type="Map"><Option type="QString" name="Änderung Schutzgut" value="5"/></Option>
                  <Option type="Map"><Option type="QString" name="Maßnahmekorrektur" value="6"/></Option>
                </Option>
              </Option>
            </config>
    """

    def __init__(self):
        self._conf = Configuration()
        self._conn = DatabaseConnection()
        self._user = PostgresUser()
        self._cache = {}

    @check_data
    def style_map(self, table: str) -> str:
        return self._cache[table]["style_map"]

    def _load_data(self):
        """Load all reference tables at once and create the

        Returns:

        """

        for index in range(len(self._conf.reference_tables)):

            table = self._conf.reference_tables[index]
            self._cache[table] = {}

            column_names = self._get_column_names(schema=self._conf.references_schema, table=table)
            self._cache[table]["column_names"] = column_names
            columns = self._get_columns(schema=self._conf.references_schema, table=table)
            self._cache[table]["columns"] = columns

            # Create a dict with the id column as key for fast access
            self._cache[table]["dict"] = dict()
            id_column = self._conf.reference_table_id_columns[index]
            id_index = column_names.index(id_column)

            for column in columns:
                self._cache[table]["dict"][column[id_index]] = column

            value_column = self._conf.reference_table_value_columns[index]

            self._cache[table]["style_map"] = self._transform_table_to_style_map_string(table=table,
                                                                                        id_column=id_column,
                                                                                        value_column=value_column)

    def _get_columns(self, schema: str, table: str) -> Optional[List[str]]:
        """Get all columns of schema.table

        Args:
            schema: The schema name
            table_name: The table name

        Returns:
            list
            The list of value lists

        """
        statement = f"SELECT * FROM {schema}.{table};"
        self._conn.execute(statement=statement)
        result = self._conn.fetch_all()
        if result is None:
            raise Exception(f"Kann Referenztabelle {table} nicht laden.")

        return result

    def _get_column_names(self, schema: str, table: str) -> List[str]:
        """Get all column names of schema.table

        Args:
            schema: The schema name
            table_name: The table name

        Returns:
            list
            The list of column names

        """

        statement = f"SELECT column_name FROM information_schema.columns " \
                    f"WHERE table_schema = '{schema}' AND table_name = '{table}';"
        self._conn.execute(statement=statement)
        self._conn.commit()
        columns = self._conn.fetch_all()
        if columns is None:
            raise Exception(f"Kann Spalten aus Referenztabelle {table} nicht laden.")

        return [entry[0] for entry in columns]

    @check_data
    def _transform_table_to_style_map_string(self, table: str, id_column: str, value_column: str) -> str:
        """Transform a table into a QGIS attribute value definition located in XML style files
        """

        columns = self._cache[table]["columns"]
        columns_names = self._cache[table]["column_names"]

        id_index = columns_names.index(id_column)
        value_index = columns_names.index(value_column)

        option_list = list()
        for entry in columns:
            option_list.append(TEMPLATE % (entry[value_index], entry[id_index]))

        content = "\n".join(option_list)
        return BODY.replace("<-- placeholder-->", content)

    @check_data
    def replace_style_value_map(self, style_file_path: str, table_list: List[Tuple[str, str]]) -> str:
        """Replace the value map placeholder in a style file with style map entries from the reference tables
        and create a new temporary file with the value map definitions.

        Args:
            table_list: List of table, placeholder tuples
            style_file_path: The path to the original style file

        Returns:
            str
            The path to the new style file with the replaced value maps
        """

        style_xml = open(style_file_path, "r").read()

        for table, placeholder in table_list:
            style_map = self._cache[table]["style_map"]
            style_xml = style_xml.replace(f"<{placeholder}/>", style_map)

        file_name = os.path.basename(style_file_path)
        file_path = os.path.join(tempfile.gettempdir(), file_name)
        file = open(file_path, "w", encoding='utf-8')
        file.write(style_xml)
        file.close()
        return file_path


if __name__ == "__main__":
    import doctest

    doctest.testmod()
